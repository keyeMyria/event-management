import pytz
from flask import url_for
from pentabarf.Conference import Conference
from pentabarf.Day import Day
from pentabarf.Event import Event
from pentabarf.Person import Person
from pentabarf.Room import Room
from sqlalchemy import DATE
from sqlalchemy import asc
from sqlalchemy import cast
from sqlalchemy import func

from app import db
from app.helpers.data_getter import DataGetter
from app.helpers.exporters.helpers import format_timedelta
from app.models.session import Session
from app.settings import get_settings


class PentabarfExporter:
    def __init__(self):
        pass

    @staticmethod
    def export(event_id):
        event = DataGetter.get_event(event_id)
        diff = (event.end_time - event.start_time)

        tz = event.timezone or 'UTC'
        tz = pytz.timezone(tz)

        conference = Conference(title=event.name, start=tz.localize(event.start_time), end=tz.localize(event.end_time),
                                days=diff.days if diff.days > 0 else 1,
                                day_change="00:00", timeslot_duration="00:15",
                                venue=event.location_name)
        dates = (db.session.query(cast(Session.start_time, DATE))
                 .filter_by(event_id=event_id)
                 .filter_by(state='accepted')
                 .filter(Session.in_trash is not True)
                 .order_by(asc(Session.start_time)).distinct().all())

        for date in dates:
            date = date[0]
            day = Day(date=date)
            microlocation_ids = list(db.session.query(Session.microlocation_id)
                                     .filter(func.date(Session.start_time) == date)
                                     .filter_by(state='accepted')
                                     .filter(Session.in_trash is not True)
                                     .order_by(asc(Session.microlocation_id)).distinct())
            for microlocation_id in microlocation_ids:
                microlocation_id = microlocation_id[0]
                microlocation = DataGetter.get_microlocation(microlocation_id)
                sessions = Session.query.filter_by(microlocation_id=microlocation_id) \
                    .filter(func.date(Session.start_time) == date) \
                    .filter_by(state='accepted') \
                    .filter(Session.in_trash is not True) \
                    .order_by(asc(Session.start_time)).all()

                room = Room(name=microlocation.name)
                for session in sessions:

                    session_event = Event(id=session.id,
                                          date=tz.localize(session.start_time),
                                          start=tz.localize(session.start_time).strftime("%H:%M"),
                                          duration=format_timedelta(session.end_time - session.start_time),
                                          track=session.track.name,
                                          abstract=session.short_abstract,
                                          title=session.title,
                                          type='Talk',
                                          description=session.long_abstract,
                                          conf_url=url_for('event_detail.display_event_detail_home',
                                                           identifier=event.identifier),
                                          full_conf_url=url_for('event_detail.display_event_detail_home',
                                                                identifier=event.identifier, _external=True),
                                          released="True" if event.schedule_published_on else "False")

                    for speaker in session.speakers:
                        person = Person(id=speaker.id, name=speaker.name)
                        session_event.add_person(person)

                    room.add_event(session_event)
                day.add_room(room)
            conference.add_day(day)

        return conference.generate("Generated by " + get_settings()['app_name'])
